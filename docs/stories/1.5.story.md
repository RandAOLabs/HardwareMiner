# Story 1.5: Basic Device Communication Test

## Status
Draft

## Story
**As a** mobile app user,
**I want** the app to successfully communicate with the Orange Pi device,
**so that** I can verify the connection is working before proceeding with setup.

## Acceptance Criteria
1. App sends test request to Orange Pi HTTPS server with authentication
2. Orange Pi responds with device information (model, status, device ID, etc.)
3. App displays successful connection confirmation to user
4. App handles communication failures with clear error messages
5. Communication works reliably across both 2.4GHz and 5GHz bands

## Tasks / Subtasks

- [ ] **Task 1: Implement device communication API** (AC: 1, 2)
  - [ ] Create comprehensive DeviceApiService with HTTPS support
  - [ ] Implement GET /device/info endpoint communication
  - [ ] Add certificate validation using trusted certificates from discovery
  - [ ] Configure request timeouts and retry mechanisms
  - [ ] Add request/response logging for debugging
  - [ ] Handle device authentication (prepare for future password-based auth)

- [ ] **Task 2: Implement device information retrieval** (AC: 2)
  - [ ] Call /device/info endpoint and parse JSON response
  - [ ] Extract device details: device_id, model, wifi_state, ip_address, mining_status
  - [ ] Validate response format and required fields
  - [ ] Handle partial or malformed device information responses
  - [ ] Cache device information for session use
  - [ ] Add device information data model and TypeScript interfaces

- [ ] **Task 3: Create communication test UI** (AC: 3)
  - [ ] Create DeviceCommunicationTest component
  - [ ] Display device information in user-friendly format
  - [ ] Show connection status and test results
  - [ ] Add communication test progress indicator
  - [ ] Display device details: ID, model, WiFi state, mining status
  - [ ] Show connection success confirmation with next steps

- [ ] **Task 4: Implement comprehensive error handling** (AC: 4)
  - [ ] Handle network connectivity errors (timeout, unreachable)
  - [ ] Handle certificate validation failures
  - [ ] Handle HTTP error responses (4xx, 5xx)
  - [ ] Handle malformed JSON responses
  - [ ] Provide specific error messages for different failure types
  - [ ] Add retry functionality with exponential backoff

- [ ] **Task 5: Test dual-band WiFi compatibility** (AC: 5)
  - [ ] Verify communication over 2.4GHz WiFi connections
  - [ ] Verify communication over 5GHz WiFi connections
  - [ ] Test connection stability across frequency bands
  - [ ] Handle band-specific connectivity issues
  - [ ] Add network frequency detection and reporting
  - [ ] Test performance differences between bands

- [ ] **Task 6: Create communication verification workflow** (AC: 1, 3)
  - [ ] Implement multi-step communication verification
  - [ ] Test /health endpoint for basic connectivity
  - [ ] Test /device/info endpoint for detailed information
  - [ ] Verify certificate consistency across requests
  - [ ] Measure and display connection latency
  - [ ] Add communication quality assessment

- [ ] **Task 7: Implement connection diagnostics** (Extended requirement)
  - [ ] Add network diagnostics (ping, traceroute if possible)
  - [ ] Test multiple API endpoints for comprehensive verification
  - [ ] Measure response times and connection quality
  - [ ] Detect and report network issues
  - [ ] Provide troubleshooting guidance for failures
  - [ ] Log detailed diagnostics for debugging

- [ ] **Task 8: Set up comprehensive testing**
  - [ ] Create unit tests for DeviceApiService
  - [ ] Test error handling scenarios with mock responses
  - [ ] Test certificate validation workflow
  - [ ] Test communication across different network conditions
  - [ ] Create integration tests with mock Orange Pi device
  - [ ] Test UI components for communication results display

## Dev Notes

### Previous Story Context
[Source: Story 1.1, 1.2, 1.4]
- Orange Pi HTTP server runs on port 8080 with HTTPS/TLS and self-signed certificates
- Device creates WiFi hotspot accessible at 192.168.12.1 (standardized IP)
- Mobile app has discovered and connected to Orange Pi hotspot
- Certificate trust established during device discovery process
- Device information available via /health and /device/info endpoints

### Tech Stack and Implementation Guidelines
[Source: architecture/tech-stack.md, Story 1.3]
- **HTTP Client:** Configured axios with HTTPS certificate handling and trusted certificate validation
- **Certificate Management:** Use CertificateManager from discovery process
- **Error Handling:** Comprehensive error handling with user-friendly messages
- **Network Testing:** Platform-specific network diagnostics where available
- **State Management:** React hooks for communication state and results

### API Endpoint Specifications
[Source: architecture/unified-project-structure.md, Story 1.1]
**Required Endpoints:**
```
GET /health
Response: {
  "status": "healthy",
  "timestamp": "2024-01-15T10:30:00Z",
  "device_id": "A1B2C3D4",
  "uptime": 3600
}

GET /device/info
Response: {
  "device_id": "A1B2C3D4",
  "model": "Orange Pi Zero 3",
  "wifi_state": "HOTSPOT_ACTIVE",
  "ip_address": "192.168.12.1",
  "ssid": "RNG-Miner-A1B2C3D4",
  "mining_status": "not_configured",
  "system_info": {
    "cpu_usage": 15.2,
    "memory_usage": 45.8,
    "disk_usage": 23.1,
    "uptime": 3600
  }
}
```

### Component Structure and File Locations
[Source: architecture/unified-project-structure.md]
```
src/screens/DeviceSetup/
├── DeviceCommunicationTest.tsx  # Communication test screen
├── DeviceInfoDisplay.tsx        # Device information display component
├── ConnectionStatus.tsx         # Connection status indicator
└── CommunicationError.tsx       # Error display component

src/services/device-api/
├── DeviceApiService.ts          # Enhanced API service
├── CommunicationTester.ts       # Communication verification logic
├── NetworkDiagnostics.ts        # Network diagnostics utilities
└── types.ts                     # API response interfaces

src/hooks/
├── useDeviceCommunication.ts    # Device communication logic
├── useCommunicationTest.ts      # Communication test workflow
└── useNetworkDiagnostics.ts     # Network diagnostics hook
```

### Device API Service Implementation
[Source: architecture/coding-standards.md]
```typescript
interface DeviceInfo {
    device_id: string;
    model: string;
    wifi_state: string;
    ip_address: string;
    ssid: string;
    mining_status: string;
    system_info: {
        cpu_usage: number;
        memory_usage: number;
        disk_usage: number;
        uptime: number;
    };
}

interface HealthResponse {
    status: string;
    timestamp: string;
    device_id: string;
    uptime: number;
}

class DeviceApiService {
    private baseUrl: string;
    private certificateManager: CertificateManager;
    private timeout: number = 10000; // 10 second timeout

    constructor(baseUrl: string, certificateManager: CertificateManager) {
        this.baseUrl = baseUrl;
        this.certificateManager = certificateManager;
    }

    async testCommunication(): Promise<CommunicationTestResult> {
        const results: CommunicationTestResult = {
            health_check: { success: false, latency: 0, error: null },
            device_info: { success: false, latency: 0, data: null, error: null },
            certificate_valid: false,
            overall_status: 'failed'
        };

        try {
            // Test health endpoint
            const healthStart = Date.now();
            const healthResponse = await this.getHealth();
            results.health_check = {
                success: true,
                latency: Date.now() - healthStart,
                error: null
            };

            // Test device info endpoint
            const infoStart = Date.now();
            const deviceInfo = await this.getDeviceInfo();
            results.device_info = {
                success: true,
                latency: Date.now() - infoStart,
                data: deviceInfo,
                error: null
            };

            // Verify certificate consistency
            results.certificate_valid = await this.verifyCertificate();
            results.overall_status = 'success';

        } catch (error) {
            results.overall_status = 'failed';
            this.handleCommunicationError(error, results);
        }

        return results;
    }

    async getHealth(): Promise<HealthResponse> {
        const response = await this.makeRequest('/health');
        return response.data;
    }

    async getDeviceInfo(): Promise<DeviceInfo> {
        const response = await this.makeRequest('/device/info');
        return response.data;
    }

    private async makeRequest(endpoint: string, options: RequestOptions = {}): Promise<any> {
        const url = `${this.baseUrl}${endpoint}`;

        try {
            const response = await axios({
                url,
                method: options.method || 'GET',
                timeout: this.timeout,
                httpsAgent: this.createHttpsAgent(),
                ...options
            });

            return response;
        } catch (error) {
            this.logRequestError(endpoint, error);
            throw this.createApiError(error);
        }
    }

    private createHttpsAgent(): https.Agent {
        return new https.Agent({
            // Use trusted certificate from certificate manager
            checkServerIdentity: (host, cert) => {
                return this.certificateManager.validateCertificate(host, cert);
            }
        });
    }
}
```

### Communication Test Workflow
```typescript
interface CommunicationTestResult {
    health_check: {
        success: boolean;
        latency: number;
        error: string | null;
    };
    device_info: {
        success: boolean;
        latency: number;
        data: DeviceInfo | null;
        error: string | null;
    };
    certificate_valid: boolean;
    overall_status: 'success' | 'failed' | 'partial';
}

const useCommunicationTest = (deviceId: string, deviceIp: string) => {
    const [testResult, setTestResult] = useState<CommunicationTestResult | null>(null);
    const [testing, setTesting] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const runCommunicationTest = async () => {
        setTesting(true);
        setError(null);

        try {
            const apiService = new DeviceApiService(
                `https://${deviceIp}:8080`,
                certificateManager
            );

            const results = await apiService.testCommunication();
            setTestResult(results);

            if (results.overall_status === 'failed') {
                setError('Communication test failed. Please check device connection.');
            }
        } catch (err) {
            setError(`Communication test failed: ${err.message}`);
        } finally {
            setTesting(false);
        }
    };

    return {
        testResult,
        testing,
        error,
        runCommunicationTest
    };
};
```

### Error Handling and User Feedback
[Source: architecture/coding-standards.md]
```typescript
class CommunicationErrorHandler {
    static handleApiError(error: any): UserFriendlyError {
        if (error.code === 'ENOTFOUND') {
            return {
                title: 'Device Not Found',
                message: 'Unable to reach the Orange Pi device. Please check WiFi connection.',
                suggestions: [
                    'Verify you are connected to the device hotspot',
                    'Check device power and LED indicators',
                    'Move closer to the device for better signal'
                ]
            };
        }

        if (error.code === 'ETIMEDOUT') {
            return {
                title: 'Connection Timeout',
                message: 'The device is taking too long to respond.',
                suggestions: [
                    'Check network signal strength',
                    'Wait a moment and try again',
                    'Restart the device if problem persists'
                ]
            };
        }

        if (error.response?.status === 500) {
            return {
                title: 'Device Error',
                message: 'The device encountered an internal error.',
                suggestions: [
                    'Wait a moment and try again',
                    'Check device logs for issues',
                    'Restart the device if problem persists'
                ]
            };
        }

        return {
            title: 'Communication Error',
            message: 'Unable to communicate with the device.',
            suggestions: [
                'Check WiFi connection',
                'Verify device is powered on',
                'Try reconnecting to device hotspot'
            ]
        };
    }
}
```

### Network Diagnostics Implementation
```typescript
class NetworkDiagnostics {
    static async testConnectivity(targetIp: string): Promise<DiagnosticsResult> {
        const results: DiagnosticsResult = {
            ping_success: false,
            latency: 0,
            network_type: 'unknown',
            signal_strength: 0,
            frequency_band: 'unknown'
        };

        try {
            // Test basic connectivity (platform specific)
            const pingResult = await this.performPing(targetIp);
            results.ping_success = pingResult.success;
            results.latency = pingResult.latency;

            // Get network information
            const networkInfo = await this.getNetworkInfo();
            results.network_type = networkInfo.type;
            results.signal_strength = networkInfo.signalStrength;
            results.frequency_band = networkInfo.frequency > 3000 ? '5GHz' : '2.4GHz';

        } catch (error) {
            console.error('Network diagnostics failed:', error);
        }

        return results;
    }
}
```

### UI Components for Communication Testing
```typescript
const DeviceCommunicationTest: React.FC<Props> = ({ deviceId, deviceIp }) => {
    const {
        testResult,
        testing,
        error,
        runCommunicationTest
    } = useCommunicationTest(deviceId, deviceIp);

    return (
        <View style={styles.container}>
            <Text style={styles.title}>Testing Device Communication</Text>

            {testing && (
                <LoadingIndicator message="Testing connection to device..." />
            )}

            {testResult && (
                <DeviceInfoDisplay
                    deviceInfo={testResult.device_info.data}
                    healthStatus={testResult.health_check.success}
                    latency={testResult.health_check.latency}
                />
            )}

            {error && (
                <CommunicationError
                    error={error}
                    onRetry={runCommunicationTest}
                />
            )}

            <Button
                title="Test Communication"
                onPress={runCommunicationTest}
                disabled={testing}
            />
        </View>
    );
};
```

### Performance and Quality Metrics
- **Response Time Targets:** Health check < 2 seconds, Device info < 5 seconds
- **Success Rate:** Aim for 95%+ success rate under normal conditions
- **Retry Strategy:** Maximum 3 attempts with exponential backoff
- **Network Tolerance:** Handle signal strength down to -70dBm
- **Band Performance:** Ensure functionality on both 2.4GHz and 5GHz

## Testing

### Unit Testing Requirements
[Source: architecture/testing-strategy.md]
- **Test File Locations:**
  - `__tests__/services/device-api/DeviceApiService.test.ts`
  - `__tests__/hooks/useCommunicationTest.test.ts`
  - `__tests__/screens/DeviceSetup/DeviceCommunicationTest.test.tsx`
- **Coverage Requirements:** 80% minimum for communication logic
- **Test Categories:**
  - API endpoint communication
  - Error handling scenarios
  - Certificate validation
  - Network diagnostics
  - UI component interactions

### Integration Testing Requirements
- **Mock Device Testing:** Test with simulated Orange Pi responses
- **Network Condition Testing:** Test under various network conditions
- **Error Scenario Testing:** Test all defined error conditions
- **Platform Testing:** Test on both iOS and Android devices
- **Dual-Band Testing:** Verify functionality on both WiFi bands

### Test Data Requirements
```typescript
// Mock device responses for testing
const mockHealthResponse: HealthResponse = {
    status: 'healthy',
    timestamp: '2024-01-15T10:30:00Z',
    device_id: 'A1B2C3D4',
    uptime: 3600
};

const mockDeviceInfo: DeviceInfo = {
    device_id: 'A1B2C3D4',
    model: 'Orange Pi Zero 3',
    wifi_state: 'HOTSPOT_ACTIVE',
    ip_address: '192.168.12.1',
    ssid: 'RNG-Miner-A1B2C3D4',
    mining_status: 'not_configured',
    system_info: {
        cpu_usage: 15.2,
        memory_usage: 45.8,
        disk_usage: 23.1,
        uptime: 3600
    }
};
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-01-15 | 1.0 | Initial story creation with device communication requirements | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation*