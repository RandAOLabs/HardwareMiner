# Story 1.1: Orange Pi HTTP Server Setup

## Status
Draft

## Story
**As a** system administrator,
**I want** a lightweight HTTP server running on the Orange Pi device,
**so that** the mobile app can communicate with the device via REST API endpoints.

## Acceptance Criteria
1. HTTP server starts automatically on Orange Pi boot
2. Server listens on a standard port (e.g., 8080) accessible via WiFi
3. Server responds to basic health check endpoint (GET /health)
4. Server logs incoming requests for debugging
5. Server handles graceful shutdown and restart

## Tasks / Subtasks

- [ ] **Task 1: Set up HTTP server foundation** (AC: 1, 2, 5)
  - [ ] Choose appropriate HTTP server technology (Python Flask/FastAPI, Node.js, or Go-based)
  - [ ] Create basic HTTP server structure listening on port 8080
  - [ ] Implement HTTPS/TLS with self-signed certificate generation on startup
  - [ ] Configure server to bind to all interfaces (0.0.0.0) for WiFi accessibility
  - [ ] Implement graceful startup, shutdown, and restart mechanisms
  - [ ] Create startup script for automatic boot execution

- [ ] **Task 2: Implement health check endpoint** (AC: 3)
  - [ ] Create GET /health endpoint
  - [ ] Return JSON response with status, timestamp, device_id, and uptime
  - [ ] Ensure endpoint responds within 2 seconds
  - [ ] Add endpoint validation and error handling

- [ ] **Task 3: Implement request logging system** (AC: 4)
  - [ ] Set up logging infrastructure with rotating log files
  - [ ] Log all incoming requests with timestamp, method, endpoint, IP address
  - [ ] Create log files in `/opt/device-software/logs/http-server.log`
  - [ ] Implement log rotation to prevent disk space issues
  - [ ] Add different log levels (INFO, DEBUG, ERROR) for debugging

- [ ] **Task 4: Create device information endpoint** (Extended requirement)
  - [ ] Create GET /device/info endpoint
  - [ ] Return device details: device_id, model, wifi_state, ip_address, mining_status
  - [ ] Integrate with WiFi state machine for current state reporting
  - [ ] Add hardware identifier generation (8-character unique device ID)

- [ ] **Task 5: Set up unit testing** (Testing requirement)
  - [ ] Create test file: `/opt/device-software/tests/test_http_server.py`
  - [ ] Test health check endpoint response format and status codes
  - [ ] Test request logging functionality
  - [ ] Test server startup, shutdown, and restart procedures
  - [ ] Test error handling for invalid requests

## Dev Notes

### Previous Story Insights
No previous story exists - this is the first story in Epic 1.

### Tech Stack and Implementation Guidelines
[Source: architecture/tech-stack.md]
- **Recommended Technology:** Python Flask or FastAPI for lightweight HTTP server
- **Port Configuration:** Standard port 8080 for device communication
- **Protocol:** HTTPS/TLS with self-signed certificates (foundation for security)
- **Logging:** Request/response logging for debugging capabilities
- **Certificate Handling:** Generate unique self-signed certificate on device startup for HTTPS communication

### File Locations and Project Structure
[Source: architecture/unified-project-structure.md]
```
/opt/device-software/
├── src/http-server/              # HTTP server implementation
├── scripts/startup.sh            # Boot-time initialization script
├── config/device-config.json     # Device-specific configuration
└── logs/http-server.log          # HTTP server request/response logs
```

### Configuration Requirements
[Source: architecture/coding-standards.md]
- **Device Configuration Format:**
```json
{
    "device_id": "A1B2C3D4",
    "http_port": 8080,
    "wifi_state_timeout": 30
}
```
- **Hardware ID Generation:** 8-character unique identifier based on multiple hardware identifiers (MAC address, CPU serial, machine ID, etc.) to ensure uniqueness across identical hardware specs

### API Endpoint Specifications
[Source: architecture/unified-project-structure.md]
Required endpoints for this story:
```
GET  /health                         # Health check endpoint
GET  /device/info                    # Device information and status
```

Response format example:
```json
{
    "status": "healthy",
    "timestamp": "2024-01-15T10:30:00Z",
    "device_id": "A1B2C3D4",
    "uptime": 3600
}
```

### Error Handling Standards
[Source: architecture/coding-standards.md]
- All error responses must follow standardized JSON format
- Include error_code, message, details, and timestamp
- Log all errors for debugging purposes
- Validate all inputs and return appropriate HTTP status codes

### Security Implementation
[Source: architecture/tech-stack.md, coding-standards.md]
- **Certificate Generation:** Generate unique self-signed certificate on device startup
- **Certificate Trust Model:** Mobile app will first encounter certificate when connecting to Orange Pi hotspot (192.168.4.1), must save and trust only this specific certificate for all future communications with this device
- **HTTPS/TLS:** All communication encrypted as foundation for future security enhancements
- **Input Validation:** Sanitization for all API parameters
- **Rate Limiting:** Preparation for 30 req/min, 100/hour burst protection

### System Integration
[Source: architecture/unified-project-structure.md]
- HTTP server must integrate with WiFi state machine for status reporting
- Server must start automatically on boot via startup script
- Device ID generation must be consistent across reboots
- Log files must use rotation to prevent disk space issues

### Docker and Mining Integration Notes
[Source: architecture/tech-stack.md]
- This story establishes HTTP server foundation
- Future stories will integrate with mining software at `/opt/mining/Randomness-Provider/`
- HTTP server will need to communicate with Docker containers for mining status
- Server must be prepared to handle mining configuration endpoints in future stories

## Testing

### Unit Testing Requirements
[Source: architecture/testing-strategy.md]
- **Test File Location:** `/opt/device-software/tests/test_http_server.py`
- **Testing Framework:** Python unittest or pytest
- **Coverage Requirements:** 80% minimum for critical paths
- **Test Categories:**
  - Health endpoint response validation
  - Request logging functionality
  - Server lifecycle (start/stop/restart)
  - Error handling scenarios
  - Configuration loading and validation

### Integration Testing Requirements
[Source: architecture/testing-strategy.md]
- Test server accessibility via WiFi connection (192.168.4.1 during hotspot mode)
- Validate HTTPS certificate generation and consistency across restarts
- Test certificate trust workflow (certificate should be identical on subsequent connections)
- Test server response time under load
- Verify log file creation and rotation
- Test graceful shutdown during system reboot

### Test Data Requirements
- Mock device configuration files
- Sample request/response data
- Error scenario test cases
- Hardware ID generation test cases

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-01-15 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2024-01-15 | 1.1 | Updated certificate handling specifics for 192.168.4.1 trust model | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation*