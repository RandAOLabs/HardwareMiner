# Story 1.6: WiFi State Machine Implementation

## Status
Draft

## Story
**As an** Orange Pi device,
**I want** a robust state machine managing WiFi connectivity and mode transitions,
**so that** I can reliably switch between setup mode and operational mode with automatic error recovery.

## Acceptance Criteria
1. Device implements comprehensive state machine with defined states: BOOT, SETUP_MODE, HOTSPOT_STARTING, HOTSPOT_ACTIVE, CREDENTIALS_RECEIVED, HOTSPOT_TEARDOWN, CONNECTING, CONNECT_RETRY, CONNECTED, NETWORK_VALIDATION, OPERATIONAL, MINING_READY, WIFI_FAILED, ERROR_RECOVERY
2. State transitions respect timing constraints: 30s hotspot teardown, 20s connection timeout, 10s retry delay
3. Device automatically falls back to setup mode after 3 failed WiFi connection attempts
4. State machine persists current state to survive crashes and reboots
5. Device provides real-time state information via API endpoints for mobile app monitoring
6. Comprehensive error recovery with manual reset capability for critical failures

## Tasks / Subtasks

- [ ] **Task 1: Design and implement state machine core** (AC: 1, 4)
  - [ ] Define all WiFi states as enumeration with clear descriptions
  - [ ] Create state machine class with current state tracking
  - [ ] Implement state transition validation with allowed transitions matrix
  - [ ] Add state persistence to survive reboots (JSON file storage)
  - [ ] Create state change logging and event history
  - [ ] Implement state machine initialization and recovery on boot

- [ ] **Task 2: Implement timing constraints and timeouts** (AC: 2)
  - [ ] Add configurable timeout system for each state
  - [ ] Implement 30-second hotspot teardown timeout
  - [ ] Add 20-second WiFi connection timeout per attempt
  - [ ] Create 10-second retry delay mechanism
  - [ ] Add watchdog timers for stuck states
  - [ ] Implement timeout-based automatic state transitions

- [ ] **Task 3: Create hotspot management states** (AC: 1)
  - [ ] Implement BOOT state with system initialization
  - [ ] Create SETUP_MODE state with hotspot preparation
  - [ ] Add HOTSPOT_STARTING state with startup sequence
  - [ ] Implement HOTSPOT_ACTIVE state with client monitoring
  - [ ] Create HOTSPOT_TEARDOWN state with graceful shutdown
  - [ ] Add hotspot status monitoring and health checks

- [ ] **Task 4: Implement WiFi connection states** (AC: 1, 3)
  - [ ] Create CREDENTIALS_RECEIVED state for setup data processing and custom password setup
  - [ ] Implement CONNECTING state with WiFi association
  - [ ] Add CONNECT_RETRY state with retry logic (max 3 attempts)
  - [ ] Create CONNECTED state with basic connectivity verification
  - [ ] Implement connection failure handling and retry counter
  - [ ] Add automatic fallback to SETUP_MODE after 3 failed attempts

- [ ] **Task 5: Implement operational and validation states** (AC: 1)
  - [ ] Create NETWORK_VALIDATION state with internet connectivity test
  - [ ] Implement OPERATIONAL state for normal device operation
  - [ ] Add MINING_READY state for mining software readiness
  - [ ] Create network validation tests (ping, DNS resolution)
  - [ ] Add operational state monitoring and health checks
  - [ ] Implement readiness checks for mining software integration

- [ ] **Task 6: Create error handling and recovery states** (AC: 3, 6)
  - [ ] Implement WIFI_FAILED state for connection failures
  - [ ] Create ERROR_RECOVERY state for critical error handling
  - [ ] Add automatic recovery mechanisms for common failures
  - [ ] Implement manual reset capability via API endpoint
  - [ ] Create error classification and recovery strategy selection
  - [ ] Add comprehensive error logging and diagnostics

- [ ] **Task 7: Build state machine API endpoints** (AC: 5)
  - [ ] Create GET /device/state endpoint for current state information
  - [ ] Add GET /device/state/history for state transition history
  - [ ] Implement POST /device/state/reset for manual state reset
  - [ ] Create GET /device/state/diagnostics for troubleshooting
  - [ ] Add real-time state change notifications (optional WebSocket)
  - [ ] Implement state change callback system for HTTP server integration

- [ ] **Task 8: Create state machine management scripts** (AC: 4)
  - [ ] Create state machine startup script for boot integration
  - [ ] Add state persistence and recovery scripts
  - [ ] Implement state machine monitoring and health check scripts
  - [ ] Create manual control scripts for debugging and testing
  - [ ] Add logging and diagnostics collection scripts
  - [ ] Create state machine configuration management

- [ ] **Task 9: Implement comprehensive testing**
  - [ ] Create unit tests for state machine logic and transitions
  - [ ] Test all timeout scenarios and timing constraints
  - [ ] Test error recovery and retry mechanisms
  - [ ] Test state persistence across reboots
  - [ ] Create integration tests with actual WiFi hardware
  - [ ] Test concurrent access and thread safety

## Dev Notes

### Previous Story Context
[Source: Story 1.1, 1.2, 1.5]
- HTTP server established with /health and /device/info endpoints
- WiFi hotspot creation capability implemented with hostapd and dnsmasq
- Device communication tested and verified with mobile app
- Certificate trust established for HTTPS communication
- Basic device information API available for state reporting

### Tech Stack and Implementation Guidelines
[Source: architecture/tech-stack.md]
- **Implementation Language:** Python for state machine logic (consistent with HTTP server)
- **State Persistence:** JSON file storage in `/opt/device-software/config/wifi-state.json`
- **Process Management:** systemd service for state machine daemon
- **Logging:** Comprehensive logging to `/opt/device-software/logs/wifi-manager.log`
- **Integration:** HTTP server integration for API endpoints

### File Locations and Project Structure
[Source: architecture/unified-project-structure.md]
```
/opt/device-software/
├── src/wifi-manager/
│   ├── wifi_state_machine.py       # Core state machine implementation
│   ├── state_definitions.py        # State enumeration and definitions
│   ├── transition_manager.py       # State transition logic
│   ├── timeout_manager.py          # Timing and timeout management
│   ├── network_manager.py          # WiFi and network operations
│   ├── persistence_manager.py      # State persistence and recovery
│   └── error_recovery.py           # Error handling and recovery logic
├── scripts/
│   ├── wifi-state-machine.sh       # State machine startup script
│   ├── state-reset.sh              # Manual state reset script
│   └── state-diagnostics.sh        # State diagnostics script
├── config/
│   ├── wifi-state.json             # Persistent state storage
│   ├── state-machine-config.json   # State machine configuration
│   └── transition-rules.json       # State transition rules
└── logs/
    ├── wifi-manager.log             # State machine operation logs
    └── state-transitions.log       # State transition history
```

### State Definitions and Descriptions
[Source: architecture/tech-stack.md, technical-assumptions.md]
```python
from enum import Enum, auto

class WiFiState(Enum):
    BOOT = auto()                    # Initial device startup and configuration check
    SETUP_MODE = auto()              # WiFi hotspot active, waiting for configuration
    HOTSPOT_STARTING = auto()        # Initializing access point mode
    HOTSPOT_ACTIVE = auto()          # Access point ready for app connection
    CREDENTIALS_RECEIVED = auto()    # WiFi credentials received from app (triggers custom password setup)
    HOTSPOT_TEARDOWN = auto()        # Gracefully disabling access point
    CONNECTING = auto()              # Attempting to connect to provided WiFi credentials
    CONNECT_RETRY = auto()           # Retrying failed WiFi connection (up to 3 attempts)
    CONNECTED = auto()               # Successfully connected to home WiFi network
    NETWORK_VALIDATION = auto()      # Verifying internet connectivity and API accessibility
    OPERATIONAL = auto()             # Network confirmed, ready for mining configuration
    MINING_READY = auto()            # Docker services running and mining operational
    WIFI_FAILED = auto()             # WiFi connection failed, returning to setup mode
    ERROR_RECOVERY = auto()          # Critical failure requiring manual intervention

# State timing constraints (seconds)
STATE_TIMEOUTS = {
    WiFiState.HOTSPOT_STARTING: 30,
    WiFiState.HOTSPOT_TEARDOWN: 30,
    WiFiState.CONNECTING: 20,
    WiFiState.CONNECT_RETRY: 10,
    WiFiState.NETWORK_VALIDATION: 10,
    WiFiState.ERROR_RECOVERY: 60
}
```

### State Machine Core Implementation
[Source: architecture/coding-standards.md]
```python
import json
import time
import threading
from typing import Optional, List, Dict
from datetime import datetime

class WiFiStateMachine:
    def __init__(self, config_path: str = '/opt/device-software/config'):
        self.config_path = config_path
        self.current_state = WiFiState.BOOT
        self.previous_state = None
        self.state_history: List[Dict] = []
        self.retry_count = 0
        self.max_retries = 3
        self.state_lock = threading.Lock()
        self.running = False

        # Load persisted state on initialization
        self.load_state()

    def transition_to(self, new_state: WiFiState, reason: str = "") -> bool:
        """Attempt state transition with validation"""
        with self.state_lock:
            if not self._is_valid_transition(self.current_state, new_state):
                self.log_error(f"Invalid transition from {self.current_state} to {new_state}")
                return False

            # Log transition
            transition = {
                'timestamp': datetime.now().isoformat(),
                'from_state': self.current_state.name,
                'to_state': new_state.name,
                'reason': reason,
                'retry_count': self.retry_count
            }

            self.state_history.append(transition)
            self.previous_state = self.current_state
            self.current_state = new_state

            # Persist state change
            self.save_state()

            # Log transition
            self.log_info(f"State transition: {self.previous_state.name} -> {new_state.name} ({reason})")

            # Trigger state entry actions
            self._on_state_entry(new_state)

            return True

    def _is_valid_transition(self, from_state: WiFiState, to_state: WiFiState) -> bool:
        """Validate if state transition is allowed"""
        # Define valid state transitions matrix
        valid_transitions = {
            WiFiState.BOOT: [WiFiState.SETUP_MODE, WiFiState.ERROR_RECOVERY],
            WiFiState.SETUP_MODE: [WiFiState.HOTSPOT_STARTING, WiFiState.ERROR_RECOVERY],
            WiFiState.HOTSPOT_STARTING: [WiFiState.HOTSPOT_ACTIVE, WiFiState.WIFI_FAILED, WiFiState.ERROR_RECOVERY],
            WiFiState.HOTSPOT_ACTIVE: [WiFiState.CREDENTIALS_RECEIVED, WiFiState.WIFI_FAILED, WiFiState.ERROR_RECOVERY],
            WiFiState.CREDENTIALS_RECEIVED: [WiFiState.HOTSPOT_TEARDOWN, WiFiState.ERROR_RECOVERY],
            WiFiState.HOTSPOT_TEARDOWN: [WiFiState.CONNECTING, WiFiState.WIFI_FAILED, WiFiState.ERROR_RECOVERY],
            WiFiState.CONNECTING: [WiFiState.CONNECTED, WiFiState.CONNECT_RETRY, WiFiState.WIFI_FAILED],
            WiFiState.CONNECT_RETRY: [WiFiState.CONNECTING, WiFiState.WIFI_FAILED, WiFiState.ERROR_RECOVERY],
            WiFiState.CONNECTED: [WiFiState.NETWORK_VALIDATION, WiFiState.WIFI_FAILED, WiFiState.ERROR_RECOVERY],
            WiFiState.NETWORK_VALIDATION: [WiFiState.OPERATIONAL, WiFiState.WIFI_FAILED, WiFiState.ERROR_RECOVERY],
            WiFiState.OPERATIONAL: [WiFiState.MINING_READY, WiFiState.WIFI_FAILED, WiFiState.ERROR_RECOVERY],
            WiFiState.MINING_READY: [WiFiState.WIFI_FAILED, WiFiState.ERROR_RECOVERY],
            WiFiState.WIFI_FAILED: [WiFiState.SETUP_MODE, WiFiState.ERROR_RECOVERY],
            WiFiState.ERROR_RECOVERY: [WiFiState.BOOT, WiFiState.SETUP_MODE]
        }

        return to_state in valid_transitions.get(from_state, [])

    def save_state(self):
        """Persist current state to disk"""
        state_data = {
            'current_state': self.current_state.name,
            'previous_state': self.previous_state.name if self.previous_state else None,
            'retry_count': self.retry_count,
            'timestamp': datetime.now().isoformat(),
            'state_history': self.state_history[-50:]  # Keep last 50 transitions
        }

        try:
            with open(f"{self.config_path}/wifi-state.json", 'w') as f:
                json.dump(state_data, f, indent=2)
        except Exception as e:
            self.log_error(f"Failed to save state: {e}")

    def load_state(self):
        """Load persisted state from disk"""
        try:
            with open(f"{self.config_path}/wifi-state.json", 'r') as f:
                state_data = json.load(f)

            self.current_state = WiFiState[state_data['current_state']]
            self.previous_state = WiFiState[state_data['previous_state']] if state_data['previous_state'] else None
            self.retry_count = state_data.get('retry_count', 0)
            self.state_history = state_data.get('state_history', [])

        except (FileNotFoundError, KeyError, json.JSONDecodeError):
            # No saved state or corrupted state file, start from BOOT
            self.current_state = WiFiState.BOOT
            self.log_info("No saved state found, starting from BOOT state")
```

### Timeout and Timer Management
```python
class TimeoutManager:
    def __init__(self, state_machine: WiFiStateMachine):
        self.state_machine = state_machine
        self.active_timers: Dict[WiFiState, threading.Timer] = {}

    def start_timeout(self, state: WiFiState, timeout_seconds: int, timeout_callback):
        """Start timeout timer for current state"""
        # Cancel existing timer for this state
        self.cancel_timeout(state)

        timer = threading.Timer(timeout_seconds, timeout_callback)
        self.active_timers[state] = timer
        timer.start()

        self.state_machine.log_info(f"Started {timeout_seconds}s timeout for state {state.name}")

    def cancel_timeout(self, state: WiFiState):
        """Cancel active timeout for state"""
        if state in self.active_timers:
            self.active_timers[state].cancel()
            del self.active_timers[state]

    def cancel_all_timeouts(self):
        """Cancel all active timeouts"""
        for timer in self.active_timers.values():
            timer.cancel()
        self.active_timers.clear()
```

### Network Operations Integration
```python
class NetworkManager:
    def __init__(self, state_machine: WiFiStateMachine):
        self.state_machine = state_machine

    async def start_hotspot(self) -> bool:
        """Start WiFi hotspot with proper state management"""
        self.state_machine.transition_to(WiFiState.HOTSPOT_STARTING, "Starting hotspot")

        try:
            # Execute hotspot startup commands
            success = await self._execute_hostapd_start()

            if success:
                self.state_machine.transition_to(WiFiState.HOTSPOT_ACTIVE, "Hotspot started successfully")
                return True
            else:
                self.state_machine.transition_to(WiFiState.WIFI_FAILED, "Hotspot startup failed")
                return False

        except Exception as e:
            self.state_machine.log_error(f"Hotspot startup exception: {e}")
            self.state_machine.transition_to(WiFiState.ERROR_RECOVERY, f"Hotspot startup exception: {e}")
            return False

    async def connect_to_wifi(self, ssid: str, password: str) -> bool:
        """Connect to WiFi with retry logic"""
        self.state_machine.transition_to(WiFiState.CONNECTING, f"Connecting to {ssid}")

        max_attempts = 3
        attempt = 0

        while attempt < max_attempts:
            attempt += 1

            try:
                success = await self._execute_wifi_connect(ssid, password)

                if success:
                    self.state_machine.transition_to(WiFiState.CONNECTED, f"Connected to {ssid}")
                    self.state_machine.retry_count = 0  # Reset retry counter
                    return True
                else:
                    if attempt < max_attempts:
                        self.state_machine.retry_count = attempt
                        self.state_machine.transition_to(WiFiState.CONNECT_RETRY, f"Retry {attempt}/{max_attempts}")
                        await asyncio.sleep(10)  # 10-second retry delay

            except Exception as e:
                self.state_machine.log_error(f"WiFi connection attempt {attempt} exception: {e}")

        # All attempts failed
        self.state_machine.transition_to(WiFiState.WIFI_FAILED, f"All connection attempts failed")
        return False
```

### API Endpoints for State Monitoring
[Source: architecture/unified-project-structure.md]
```python
# Add to HTTP server (integrate with Story 1.1)
@app.route('/device/state', methods=['GET'])
def get_device_state():
    """Get current WiFi state machine status"""
    state_info = {
        'current_state': state_machine.current_state.name,
        'previous_state': state_machine.previous_state.name if state_machine.previous_state else None,
        'retry_count': state_machine.retry_count,
        'max_retries': state_machine.max_retries,
        'timestamp': datetime.now().isoformat(),
        'uptime': state_machine.get_uptime(),
        'state_description': STATE_DESCRIPTIONS[state_machine.current_state]
    }

    return jsonify({
        'success': True,
        'data': state_info
    })

@app.route('/device/state/history', methods=['GET'])
def get_state_history():
    """Get state transition history"""
    return jsonify({
        'success': True,
        'data': {
            'transitions': state_machine.state_history[-20:],  # Last 20 transitions
            'total_transitions': len(state_machine.state_history)
        }
    })

@app.route('/device/state/reset', methods=['POST'])
def reset_state_machine():
    """Manual state machine reset"""
    try:
        state_machine.reset_to_boot("Manual reset requested")
        return jsonify({
            'success': True,
            'message': 'State machine reset successfully'
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Reset failed: {str(e)}'
        }), 500
```

### Error Recovery and Diagnostics
[Source: architecture/coding-standards.md]
```python
class ErrorRecovery:
    def __init__(self, state_machine: WiFiStateMachine):
        self.state_machine = state_machine

    def handle_critical_error(self, error: Exception, context: str):
        """Handle critical errors with recovery strategies"""
        error_info = {
            'error_type': type(error).__name__,
            'error_message': str(error),
            'context': context,
            'timestamp': datetime.now().isoformat(),
            'current_state': self.state_machine.current_state.name
        }

        self.state_machine.log_error(f"Critical error in {context}: {error}")

        # Determine recovery strategy based on error type and context
        if self._is_recoverable_error(error, context):
            self._attempt_automatic_recovery(error_info)
        else:
            self.state_machine.transition_to(WiFiState.ERROR_RECOVERY, f"Critical error: {error}")

    def _is_recoverable_error(self, error: Exception, context: str) -> bool:
        """Determine if error can be recovered automatically"""
        recoverable_errors = [
            'ConnectionError',
            'TimeoutError',
            'TemporaryFailure'
        ]

        return type(error).__name__ in recoverable_errors

    def _attempt_automatic_recovery(self, error_info: Dict):
        """Attempt automatic recovery for recoverable errors"""
        # Implement recovery strategies based on error context
        recovery_strategies = {
            'hotspot_failure': self._recover_hotspot,
            'wifi_connection': self._recover_wifi_connection,
            'network_validation': self._recover_network_validation
        }

        context = error_info['context']
        if context in recovery_strategies:
            recovery_strategies[context](error_info)
        else:
            self.state_machine.transition_to(WiFiState.ERROR_RECOVERY, "Unknown error context")
```

### Integration with Existing Components
- **HTTP Server Integration:** Add state machine API endpoints to existing HTTP server
- **Hotspot Management:** Integrate with hostapd and dnsmasq from Story 1.2
- **Device Information:** Update /device/info endpoint to include current WiFi state
- **Certificate Management:** Ensure state transitions don't affect certificate trust
- **Logging Integration:** Coordinate with existing HTTP server logging

### Performance and Resource Considerations
- State machine runs as lightweight background service
- Minimal CPU usage during steady states
- Efficient state persistence with batched writes
- Memory usage optimized with rolling state history
- Network operations use async/await for non-blocking execution

## Testing

### Unit Testing Requirements
[Source: architecture/testing-strategy.md]
- **Test File Location:** `/opt/device-software/tests/test_wifi_state_machine.py`
- **Testing Framework:** Python unittest with async support
- **Coverage Requirements:** 90% minimum for state machine logic (critical system)
- **Test Categories:**
  - State transition validation
  - Timeout handling and timing constraints
  - Error recovery mechanisms
  - State persistence and recovery
  - Concurrent access and thread safety

### Integration Testing Requirements
- **Hardware Integration:** Test with actual WiFi hardware and network connections
- **State Transition Testing:** Test complete workflows from boot to operational
- **Error Scenario Testing:** Test all error conditions and recovery paths
- **Timing Testing:** Verify all timeout constraints under various conditions
- **API Integration:** Test state machine API endpoints with HTTP server

### Test Files Structure
```
/opt/device-software/tests/
├── test_wifi_state_machine.py      # Core state machine tests
├── test_state_transitions.py       # State transition validation
├── test_timeout_manager.py         # Timeout and timing tests
├── test_network_manager.py         # Network operations tests
├── test_error_recovery.py          # Error handling tests
├── test_api_integration.py         # API endpoint tests
└── integration/
    ├── test_complete_workflow.py   # End-to-end workflow tests
    └── test_hardware_integration.py # Physical hardware tests
```

### Mock Data and Test Scenarios
```python
# Test scenarios for comprehensive state machine testing
test_scenarios = [
    {
        'name': 'normal_setup_flow',
        'states': [
            WiFiState.BOOT,
            WiFiState.SETUP_MODE,
            WiFiState.HOTSPOT_STARTING,
            WiFiState.HOTSPOT_ACTIVE,
            WiFiState.CREDENTIALS_RECEIVED,
            WiFiState.HOTSPOT_TEARDOWN,
            WiFiState.CONNECTING,
            WiFiState.CONNECTED,
            WiFiState.NETWORK_VALIDATION,
            WiFiState.OPERATIONAL
        ]
    },
    {
        'name': 'wifi_retry_scenario',
        'states': [
            WiFiState.CONNECTING,
            WiFiState.CONNECT_RETRY,
            WiFiState.CONNECTING,
            WiFiState.CONNECT_RETRY,
            WiFiState.CONNECTING,
            WiFiState.WIFI_FAILED,
            WiFiState.SETUP_MODE
        ]
    },
    {
        'name': 'error_recovery_flow',
        'states': [
            WiFiState.HOTSPOT_ACTIVE,
            WiFiState.ERROR_RECOVERY,
            WiFiState.BOOT,
            WiFiState.SETUP_MODE
        ]
    }
]
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-01-15 | 1.0 | Initial story creation with comprehensive WiFi state machine requirements | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation*