# Story 1.4: Device Discovery Implementation

## Status
Draft

## Story
**As a** mobile app user,
**I want** the app to automatically discover available Orange Pi devices,
**so that** I can select which device to configure.

## Acceptance Criteria
1. App scans for devices with Orange Pi hotspot SSID pattern "RNG-Miner-XXXXXXXX"
2. App displays list of discovered devices with signal strength
3. App can connect to selected Orange Pi hotspot using hardcoded password
4. App verifies HTTP server accessibility after connection
5. App handles cases where no devices are found

## Tasks / Subtasks

- [ ] **Task 1: Implement WiFi network scanning** (AC: 1, 5)
  - [ ] Create WiFiScanner service for network discovery
  - [ ] Implement periodic WiFi network scanning (every 5-10 seconds)
  - [ ] Filter networks by SSID pattern "RNG-Miner-*"
  - [ ] Extract device ID from SSID (8-character suffix)
  - [ ] Handle WiFi scanning permissions for both platforms
  - [ ] Add error handling for scanning failures and empty results

- [ ] **Task 2: Create device discovery UI** (AC: 2, 5)
  - [ ] Create DeviceDiscoveryScreen component
  - [ ] Display list of discovered devices with device ID and signal strength
  - [ ] Add refresh/rescan functionality with loading indicator
  - [ ] Implement device selection interface
  - [ ] Show "No devices found" state with helpful instructions
  - [ ] Add device info display (device ID, signal strength, SSID)

- [ ] **Task 3: Implement hotspot connection** (AC: 3)
  - [ ] Create WiFi connection service
  - [ ] Implement connection to selected device hotspot
  - [ ] Use hardcoded password "RNG-Miner-Password-123"
  - [ ] Handle connection timeout and failure scenarios
  - [ ] Show connection progress to user
  - [ ] Store connected device information

- [ ] **Task 4: Verify HTTP server accessibility** (AC: 4)
  - [ ] Implement device connectivity verification
  - [ ] Test HTTPS connection to device (https://192.168.12.1:8080/health)
  - [ ] Handle certificate trust workflow for first connection
  - [ ] Validate device response and extract device information
  - [ ] Add retry mechanism for connectivity verification
  - [ ] Handle cases where device is unreachable after WiFi connection

- [ ] **Task 5: Create device selection and connection flow** (AC: 3, 4)
  - [ ] Implement device selection UI with confirmation
  - [ ] Show connection progress with status updates
  - [ ] Handle user cancellation of connection process
  - [ ] Add connection success/failure feedback
  - [ ] Navigate to next screen after successful connection
  - [ ] Store selected device information for future use

- [ ] **Task 6: Implement certificate trust management** (Integration requirement)
  - [ ] Create CertificateManager service
  - [ ] Handle self-signed certificate trust workflow
  - [ ] Present certificate trust dialog to user
  - [ ] Store trusted certificates securely (device-specific)
  - [ ] Validate certificate consistency across connections
  - [ ] Handle certificate trust failures and user rejection

- [ ] **Task 7: Add error handling and edge cases** (AC: 5)
  - [ ] Handle WiFi permission denied scenarios
  - [ ] Manage network connection errors and timeouts
  - [ ] Handle device unreachability after WiFi connection
  - [ ] Manage certificate trust failures
  - [ ] Add retry mechanisms for transient failures
  - [ ] Provide clear error messages and recovery options

- [ ] **Task 8: Set up comprehensive testing**
  - [ ] Create unit tests for WiFi scanning logic
  - [ ] Test device filtering and SSID pattern matching
  - [ ] Test connection workflow and error scenarios
  - [ ] Test certificate trust management
  - [ ] Create integration tests with mock devices
  - [ ] Test UI components and user interactions

## Dev Notes

### Previous Story Context
[Source: Story 1.1, 1.2, 1.3]
- Orange Pi creates WiFi hotspot with SSID "RNG-Miner-{8-char-device-id}"
- Hotspot uses hardcoded password "RNG-Miner-Password-123"
- HTTP server accessible at 192.168.12.1:8080 with HTTPS/TLS
- React Native app has WiFi scanning capabilities and HTTP client
- Self-signed certificates must be trusted on first connection

### Tech Stack and Implementation Guidelines
[Source: architecture/tech-stack.md, Story 1.3]
- **WiFi Library:** react-native-wifi-reborn for cross-platform WiFi operations
- **HTTP Client:** Configured axios with HTTPS certificate handling
- **State Management:** React hooks (useState, useEffect) or Context API
- **Navigation:** React Navigation for screen transitions
- **Storage:** AsyncStorage or SecureStorage for device and certificate data

### Component Structure and File Locations
[Source: architecture/unified-project-structure.md]
```
src/screens/DeviceDiscovery/
├── DeviceDiscoveryScreen.tsx    # Main discovery screen component
├── DeviceList.tsx               # Device list display component
├── DeviceItem.tsx               # Individual device item component
└── NoDevicesFound.tsx           # Empty state component

src/services/
├── wifi-scanner/
│   ├── WiFiScanner.ts           # WiFi scanning service
│   ├── DeviceFilter.ts          # Orange Pi device filtering logic
│   └── types.ts                 # TypeScript interfaces
├── device-api/
│   ├── DeviceApiService.ts      # HTTP client for device communication
│   └── ConnectivityVerifier.ts  # Device reachability testing
└── certificate-manager/
    ├── CertificateManager.ts    # Certificate trust management
    └── TrustStore.ts           # Secure certificate storage

src/hooks/
├── useDeviceDiscovery.ts        # Device scanning and filtering logic
├── useWiFiConnection.ts         # WiFi connection management
└── useCertificateTrust.ts       # Certificate trust workflow
```

### WiFi Scanning Implementation
[Source: architecture/coding-standards.md]
```typescript
interface DiscoveredDevice {
    deviceId: string;        // 8-character hardware ID
    ssid: string;           // Full SSID "RNG-Miner-XXXXXXXX"
    bssid: string;          // MAC address
    signalStrength: number; // Signal level in dBm
    frequency: number;      // WiFi frequency
    timestamp: number;      // Discovery timestamp
    ipAddress: string;      // Expected device IP (192.168.12.1)
}

class WiFiScanner {
    async scanForOrangePiDevices(): Promise<DiscoveredDevice[]> {
        try {
            const networks = await WifiManager.loadWifiList();

            return networks
                .filter(network => network.SSID.match(/^RNG-Miner-[A-Z0-9]{8}$/))
                .map(network => ({
                    deviceId: network.SSID.substring(10), // Extract device ID
                    ssid: network.SSID,
                    bssid: network.BSSID,
                    signalStrength: network.level,
                    frequency: network.frequency,
                    timestamp: Date.now(),
                    ipAddress: '192.168.12.1'
                }))
                .sort((a, b) => b.signalStrength - a.signalStrength); // Sort by signal strength
        } catch (error) {
            console.error('WiFi scanning failed:', error);
            throw new Error('Unable to scan for WiFi networks');
        }
    }
}
```

### WiFi Connection Implementation
```typescript
class WiFiConnectionService {
    private static readonly HOTSPOT_PASSWORD = 'RNG-Miner-Password-123';
    private static readonly CONNECTION_TIMEOUT = 30000; // 30 seconds

    async connectToDevice(device: DiscoveredDevice): Promise<boolean> {
        try {
            // Connect to device hotspot
            const connected = await WifiManager.connectToProtectedSSID(
                device.ssid,
                WiFiConnectionService.HOTSPOT_PASSWORD,
                false // Not WEP
            );

            if (!connected) {
                throw new Error(`Failed to connect to device ${device.deviceId}`);
            }

            // Verify connectivity with timeout
            await this.verifyDeviceConnectivity(device);
            return true;

        } catch (error) {
            console.error(`Connection to device ${device.deviceId} failed:`, error);
            throw error;
        }
    }

    private async verifyDeviceConnectivity(device: DiscoveredDevice): Promise<void> {
        const apiService = new DeviceApiService(`https://${device.ipAddress}:8080`);

        try {
            const response = await apiService.getHealth();
            if (response.status !== 'healthy') {
                throw new Error('Device health check failed');
            }
        } catch (error) {
            throw new Error('Device is not reachable via HTTP');
        }
    }
}
```

### Certificate Trust Workflow
[Source: architecture/coding-standards.md, Story 1.1]
```typescript
interface TrustedCertificate {
    deviceId: string;
    ipAddress: string;
    certificate: string;
    fingerprint: string;
    trustTimestamp: number;
}

class CertificateManager {
    private trustedCertificates: Map<string, TrustedCertificate> = new Map();

    async handleCertificateTrust(
        deviceId: string,
        ipAddress: string,
        certificate: string
    ): Promise<boolean> {
        // Check if certificate is already trusted
        const existing = this.trustedCertificates.get(deviceId);
        if (existing && existing.certificate === certificate) {
            return true;
        }

        // Present certificate trust dialog to user
        const userAccepted = await this.presentTrustDialog(deviceId, certificate);

        if (userAccepted) {
            // Store trusted certificate
            const trustedCert: TrustedCertificate = {
                deviceId,
                ipAddress,
                certificate,
                fingerprint: this.calculateFingerprint(certificate),
                trustTimestamp: Date.now()
            };

            this.trustedCertificates.set(deviceId, trustedCert);
            await this.persistTrustedCertificates();
            return true;
        }

        return false;
    }

    private async presentTrustDialog(deviceId: string, certificate: string): Promise<boolean> {
        // Show certificate trust dialog with device ID and certificate details
        // Return user's trust decision
    }
}
```

### Device Discovery UI Components
```typescript
// DeviceDiscoveryScreen component structure
const DeviceDiscoveryScreen: React.FC = () => {
    const {
        devices,
        scanning,
        error,
        scanForDevices
    } = useDeviceDiscovery();

    const {
        connectToDevice,
        connecting,
        connectionError
    } = useWiFiConnection();

    const handleDeviceSelect = async (device: DiscoveredDevice) => {
        try {
            await connectToDevice(device);
            navigation.navigate('DeviceSetup', { deviceId: device.deviceId });
        } catch (error) {
            // Handle connection error
        }
    };

    return (
        <View>
            <DeviceList
                devices={devices}
                onDeviceSelect={handleDeviceSelect}
                loading={scanning || connecting}
            />
            {devices.length === 0 && !scanning && (
                <NoDevicesFound onRetry={scanForDevices} />
            )}
        </View>
    );
};
```

### Error Handling and User Feedback
[Source: architecture/coding-standards.md]
- **WiFi Permission Errors:** Guide user to enable location services and WiFi permissions
- **No Devices Found:** Provide troubleshooting steps (check device power, proximity)
- **Connection Failures:** Offer retry options and troubleshooting guidance
- **Certificate Trust Issues:** Explain certificate security and provide clear options
- **Network Timeouts:** Implement exponential backoff and clear timeout messaging

### Performance Considerations
- Implement debouncing for frequent WiFi scans to conserve battery
- Cache discovered devices for short periods to reduce scanning frequency
- Use background tasks appropriately for network operations
- Optimize UI updates to prevent unnecessary re-renders during scanning

### Platform-Specific Considerations
**Android:**
- Handle runtime permissions for location and WiFi access
- Consider Android 10+ WiFi restrictions and workarounds
- Test on different Android versions and OEM customizations

**iOS:**
- Handle iOS WiFi connection limitations and user consent
- Work within iOS WiFi API restrictions
- Test certificate trust on iOS certificate store integration

## Testing

### Unit Testing Requirements
[Source: architecture/testing-strategy.md]
- **Test File Locations:**
  - `__tests__/screens/DeviceDiscovery/`
  - `__tests__/services/wifi-scanner/`
  - `__tests__/hooks/useDeviceDiscovery.test.ts`
- **Coverage Requirements:** 80% minimum for device discovery logic
- **Test Categories:**
  - WiFi scanning and device filtering
  - Device connection workflow
  - Certificate trust management
  - Error handling scenarios
  - UI component interactions

### Integration Testing Requirements
- **Mock WiFi Networks:** Test with simulated Orange Pi devices
- **Connection Testing:** Test complete discovery-to-connection workflow
- **Certificate Testing:** Test certificate trust workflow with mock certificates
- **Platform Testing:** Test on both iOS and Android devices
- **Network Conditions:** Test under various WiFi conditions and signal strengths

### Test Data Requirements
```typescript
// Mock discovered devices for testing
const mockDevices: DiscoveredDevice[] = [
    {
        deviceId: 'A1B2C3D4',
        ssid: 'RNG-Miner-A1B2C3D4',
        bssid: '00:11:22:33:44:55',
        signalStrength: -45,
        frequency: 2437,
        timestamp: Date.now(),
        ipAddress: '192.168.12.1'
    },
    {
        deviceId: 'E5F6G7H8',
        ssid: 'RNG-Miner-E5F6G7H8',
        bssid: '66:77:88:99:AA:BB',
        signalStrength: -67,
        frequency: 5220,
        timestamp: Date.now(),
        ipAddress: '192.168.12.1'
    }
];
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-01-15 | 1.0 | Initial story creation with device discovery requirements | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation*