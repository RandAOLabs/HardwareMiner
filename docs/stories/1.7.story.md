# Story 1.7: Enhanced Security Foundation

## Status
Draft

## Story
**As a** system administrator,
**I want** basic security measures implemented for device communication,
**so that** we have a foundation for future security enhancements.

## Acceptance Criteria
1. All API communication uses HTTPS/TLS with self-signed certificates
2. Mobile app trusts self-signed certificates from device IP ranges (192.168.x.x)
3. API endpoints implement rate limiting (30 req/min, 100/hour burst)
4. All user inputs (WiFi credentials, seed phrases, scripts) undergo validation and sanitization
5. System prompts user to set custom device password during initial setup (hotspot password remains hardcoded for future setup access)
6. Clear upgrade path documented for V1.1 security enhancements (dynamic tokens, encryption)

## Tasks / Subtasks

- [ ] **Task 1: Enhance HTTPS/TLS implementation** (AC: 1)
  - [ ] Generate strong self-signed certificates with proper key lengths (2048-bit RSA minimum)
  - [ ] Implement certificate rotation capability for future security updates
  - [ ] Add TLS version enforcement (TLS 1.2 minimum)
  - [ ] Configure secure cipher suites and disable weak ciphers
  - [ ] Add certificate validation and integrity checks
  - [ ] Implement certificate fingerprint generation and storage

- [ ] **Task 2: Implement certificate trust management** (AC: 2)
  - [ ] Create certificate trust validation for 192.168.x.x IP ranges
  - [ ] Implement certificate pinning mechanism for mobile app
  - [ ] Add certificate trust persistence across app restarts
  - [ ] Create certificate trust revocation capability
  - [ ] Add certificate expiration monitoring and warnings
  - [ ] Implement certificate trust audit logging

- [ ] **Task 3: Implement API rate limiting** (AC: 3)
  - [ ] Add rate limiting middleware to HTTP server
  - [ ] Implement 30 requests per minute limit per IP
  - [ ] Add 100 requests per hour burst limit
  - [ ] Create rate limiting bypass for critical endpoints (health check)
  - [ ] Add rate limiting status headers for client information
  - [ ] Implement rate limiting persistence across server restarts

- [ ] **Task 4: Create comprehensive input validation** (AC: 4)
  - [ ] Implement WiFi credential validation (SSID format, password strength)
  - [ ] Add seed phrase validation (12-word format, dictionary check)
  - [ ] Create script input sanitization for mining configuration
  - [ ] Add JSON payload validation with schemas
  - [ ] Implement SQL injection prevention (if applicable)
  - [ ] Add XSS prevention for all text inputs

- [ ] **Task 5: Implement custom device password system** (AC: 5)
  - [ ] Create password setup workflow during initial device configuration
  - [ ] Add password strength requirements (minimum 8 chars, complexity)
  - [ ] Implement password hashing with bcrypt or similar
  - [ ] Create password change capability via API
  - [ ] Add password-based authentication for sensitive endpoints (API only, not hotspot)
  - [ ] Implement password reset mechanism with device reset
  - [ ] Ensure hotspot password remains "RNG-Miner-Password-123" for future setup access

- [ ] **Task 6: Design security upgrade path** (AC: 6)
  - [ ] Document V1.1 dynamic token implementation plan
  - [ ] Design encrypted configuration storage architecture
  - [ ] Plan certificate-based authentication for V1.2
  - [ ] Document enterprise security features for V2.0
  - [ ] Create security configuration management system
  - [ ] Add security audit and compliance documentation

- [ ] **Task 7: Implement security logging and monitoring**
  - [ ] Add comprehensive security event logging
  - [ ] Log all authentication attempts (success and failure)
  - [ ] Monitor and log rate limiting violations
  - [ ] Track certificate trust events and changes
  - [ ] Add security metrics collection and reporting
  - [ ] Implement security alert system for critical events

- [ ] **Task 8: Create security testing and validation**
  - [ ] Create security-focused unit tests
  - [ ] Test certificate validation and trust mechanisms
  - [ ] Test rate limiting under various load conditions
  - [ ] Validate input sanitization against common attacks
  - [ ] Test password system security and strength
  - [ ] Perform basic security vulnerability assessment

## Dev Notes

### Previous Story Context
[Source: Story 1.1, 1.2, 1.4, 1.5, 1.6]
- HTTP server established with HTTPS/TLS using self-signed certificates
- Mobile app has certificate trust workflow for device connections
- API endpoints available for device communication and state monitoring
- WiFi state machine implemented with API integration
- Device discovery and communication workflows established

### Tech Stack and Security Guidelines
[Source: architecture/tech-stack.md, coding-standards.md]
- **TLS Implementation:** OpenSSL with strong cipher suites
- **Certificate Management:** Self-signed certificates with proper validation
- **Rate Limiting:** Token bucket algorithm or sliding window
- **Input Validation:** Comprehensive sanitization and validation libraries
- **Password Hashing:** bcrypt, scrypt, or Argon2 for secure password storage
- **Logging:** Security-focused logging with proper data protection

### File Locations and Project Structure
[Source: architecture/unified-project-structure.md]
```
/opt/device-software/
├── src/security/
│   ├── certificate_manager.py      # Certificate generation and management
│   ├── rate_limiter.py             # API rate limiting implementation
│   ├── input_validator.py          # Input validation and sanitization
│   ├── password_manager.py         # Device password management
│   ├── security_logger.py          # Security event logging
│   └── auth_middleware.py          # Authentication middleware
├── config/
│   ├── security-config.json        # Security configuration settings
│   ├── rate-limits.json            # Rate limiting configuration
│   ├── validation-schemas.json     # Input validation schemas
│   └── certs/
│       ├── device.crt              # Device certificate
│       ├── device.key              # Device private key
│       └── cert-info.json          # Certificate metadata
├── scripts/
│   ├── generate-cert.sh            # Certificate generation script
│   ├── security-audit.sh           # Security audit script
│   └── password-reset.sh           # Device password reset script
└── logs/
    ├── security.log                # Security event logs
    ├── auth.log                    # Authentication logs
    └── rate-limit.log              # Rate limiting logs
```

### Certificate Management Implementation
[Source: architecture/coding-standards.md]
```python
import ssl
import hashlib
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from datetime import datetime, timedelta

class CertificateManager:
    def __init__(self, cert_dir: str = '/opt/device-software/config/certs'):
        self.cert_dir = cert_dir
        self.device_id = self.get_device_id()

    def generate_device_certificate(self) -> bool:
        """Generate strong self-signed certificate for device"""
        try:
            # Generate RSA private key (2048-bit minimum)
            private_key = rsa.generate_private_key(
                public_exponent=65537,
                key_size=2048,
            )

            # Create certificate
            subject = issuer = x509.Name([
                x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
                x509.NameAttribute(NameOID.ORGANIZATION_NAME, "RNG Miner"),
                x509.NameAttribute(NameOID.COMMON_NAME, f"RNG-Miner-{self.device_id}"),
            ])

            cert = x509.CertificateBuilder().subject_name(
                subject
            ).issuer_name(
                issuer
            ).public_key(
                private_key.public_key()
            ).serial_number(
                x509.random_serial_number()
            ).not_valid_before(
                datetime.utcnow()
            ).not_valid_after(
                datetime.utcnow() + timedelta(days=1825)  # 5 year validity
            ).add_extension(
                x509.SubjectAlternativeName([
                    x509.IPAddress(ipaddress.IPv4Address("192.168.12.1")),
                    x509.DNSName(f"rng-miner-{self.device_id}.local"),
                ]),
                critical=False,
            ).sign(private_key, hashes.SHA256())

            # Save certificate and key
            cert_path = f"{self.cert_dir}/device.crt"
            key_path = f"{self.cert_dir}/device.key"

            with open(cert_path, "wb") as f:
                f.write(cert.public_bytes(serialization.Encoding.PEM))

            with open(key_path, "wb") as f:
                f.write(private_key.private_bytes(
                    encoding=serialization.Encoding.PEM,
                    format=serialization.PrivateFormat.PKCS8,
                    encryption_algorithm=serialization.NoEncryption()
                ))

            # Generate and store certificate fingerprint
            fingerprint = self.get_certificate_fingerprint(cert)
            self.store_certificate_info(fingerprint, cert)

            return True

        except Exception as e:
            self.log_error(f"Certificate generation failed: {e}")
            return False

    def get_certificate_fingerprint(self, cert: x509.Certificate) -> str:
        """Generate SHA256 fingerprint of certificate"""
        return hashlib.sha256(cert.public_bytes(serialization.Encoding.DER)).hexdigest()

    def store_certificate_info(self, fingerprint: str, cert: x509.Certificate):
        """Store certificate metadata"""
        cert_info = {
            'device_id': self.device_id,
            'fingerprint': fingerprint,
            'subject': cert.subject.rfc4514_string(),
            'issuer': cert.issuer.rfc4514_string(),
            'not_valid_before': cert.not_valid_before.isoformat(),
            'not_valid_after': cert.not_valid_after.isoformat(),
            'generated_timestamp': datetime.utcnow().isoformat()
        }

        with open(f"{self.cert_dir}/cert-info.json", 'w') as f:
            json.dump(cert_info, f, indent=2)
```

### Rate Limiting Implementation
```python
import time
from typing import Dict, Optional
from threading import Lock

class RateLimiter:
    def __init__(self, requests_per_minute: int = 30, burst_limit: int = 100):
        self.requests_per_minute = requests_per_minute
        self.burst_limit = burst_limit
        self.client_requests: Dict[str, Dict] = {}
        self.lock = Lock()

    def is_allowed(self, client_ip: str, endpoint: str = None) -> bool:
        """Check if request is allowed under rate limits"""
        with self.lock:
            current_time = time.time()

            # Initialize client tracking if new
            if client_ip not in self.client_requests:
                self.client_requests[client_ip] = {
                    'minute_requests': [],
                    'hour_requests': [],
                    'last_request': current_time
                }

            client_data = self.client_requests[client_ip]

            # Clean old requests (older than 1 hour)
            client_data['minute_requests'] = [
                req_time for req_time in client_data['minute_requests']
                if current_time - req_time < 60  # Last minute
            ]
            client_data['hour_requests'] = [
                req_time for req_time in client_data['hour_requests']
                if current_time - req_time < 3600  # Last hour
            ]

            # Check limits
            minute_count = len(client_data['minute_requests'])
            hour_count = len(client_data['hour_requests'])

            # Allow health check endpoint with higher limits
            if endpoint == '/health':
                if minute_count >= self.requests_per_minute * 2:  # Double limit for health
                    return False
            else:
                if minute_count >= self.requests_per_minute:
                    return False

            if hour_count >= self.burst_limit:
                return False

            # Record request
            client_data['minute_requests'].append(current_time)
            client_data['hour_requests'].append(current_time)
            client_data['last_request'] = current_time

            return True

    def get_rate_limit_info(self, client_ip: str) -> Dict:
        """Get current rate limit status for client"""
        if client_ip not in self.client_requests:
            return {
                'requests_remaining_minute': self.requests_per_minute,
                'requests_remaining_hour': self.burst_limit,
                'reset_time': int(time.time() + 60)
            }

        client_data = self.client_requests[client_ip]
        current_time = time.time()

        # Count current requests
        minute_count = len([
            req for req in client_data['minute_requests']
            if current_time - req < 60
        ])
        hour_count = len([
            req for req in client_data['hour_requests']
            if current_time - req < 3600
        ])

        return {
            'requests_remaining_minute': max(0, self.requests_per_minute - minute_count),
            'requests_remaining_hour': max(0, self.burst_limit - hour_count),
            'reset_time': int(current_time + 60)
        }
```

### Input Validation and Sanitization
```python
import re
import json
from typing import Any, Dict, List
import html

class InputValidator:
    def __init__(self):
        # BIP39 word list for seed phrase validation
        self.bip39_words = self.load_bip39_wordlist()

    def validate_wifi_credentials(self, ssid: str, password: str) -> Dict:
        """Validate WiFi network credentials"""
        errors = {}

        # SSID validation
        if not ssid or not ssid.strip():
            errors['ssid'] = 'Network name cannot be empty'
        elif len(ssid) > 32:
            errors['ssid'] = 'Network name cannot exceed 32 characters'
        elif not re.match(r'^[a-zA-Z0-9\-_\s\.]+$', ssid):
            errors['ssid'] = 'Network name contains invalid characters'

        # Password validation
        if not password:
            errors['password'] = 'Password cannot be empty'
        elif len(password) < 8:
            errors['password'] = 'Password must be at least 8 characters long'
        elif len(password) > 63:
            errors['password'] = 'Password cannot exceed 63 characters'

        return {
            'valid': len(errors) == 0,
            'errors': errors,
            'sanitized': {
                'ssid': html.escape(ssid.strip()) if ssid else '',
                'password': password  # Don't log or escape passwords
            }
        }

    def validate_seed_phrase(self, seed_phrase: str) -> Dict:
        """Validate 12-word BIP39 seed phrase"""
        errors = {}

        if not seed_phrase or not seed_phrase.strip():
            errors['seed_phrase'] = 'Seed phrase cannot be empty'
            return {'valid': False, 'errors': errors}

        words = seed_phrase.strip().lower().split()

        if len(words) != 12:
            errors['seed_phrase'] = 'Seed phrase must contain exactly 12 words'
        else:
            invalid_words = [word for word in words if word not in self.bip39_words]
            if invalid_words:
                errors['seed_phrase'] = f'Invalid words in seed phrase: {", ".join(invalid_words)}'

        return {
            'valid': len(errors) == 0,
            'errors': errors,
            'word_count': len(words),
            'sanitized': ' '.join(words) if len(errors) == 0 else None
        }

    def validate_device_password(self, password: str) -> Dict:
        """Validate device password strength"""
        errors = {}

        if not password:
            errors['password'] = 'Password cannot be empty'
        elif len(password) < 8:
            errors['password'] = 'Password must be at least 8 characters long'
        elif len(password) > 128:
            errors['password'] = 'Password cannot exceed 128 characters'
        else:
            # Check password complexity
            if not re.search(r'[a-z]', password):
                errors['password'] = 'Password must contain at least one lowercase letter'
            elif not re.search(r'[A-Z]', password):
                errors['password'] = 'Password must contain at least one uppercase letter'
            elif not re.search(r'\d', password):
                errors['password'] = 'Password must contain at least one number'

        return {
            'valid': len(errors) == 0,
            'errors': errors,
            'strength': self.calculate_password_strength(password) if len(errors) == 0 else 0
        }

    def sanitize_json_input(self, json_data: Any) -> Any:
        """Recursively sanitize JSON input data"""
        if isinstance(json_data, dict):
            return {key: self.sanitize_json_input(value) for key, value in json_data.items()}
        elif isinstance(json_data, list):
            return [self.sanitize_json_input(item) for item in json_data]
        elif isinstance(json_data, str):
            return html.escape(json_data.strip())
        else:
            return json_data
```

### Password Management System
```python
import bcrypt
import secrets
from typing import Optional

class PasswordManager:
    def __init__(self, config_path: str = '/opt/device-software/config'):
        self.config_path = config_path
        self.password_file = f"{config_path}/device-password.json"

    def set_device_password(self, password: str) -> bool:
        """Set and hash device password"""
        try:
            # Generate salt and hash password
            salt = bcrypt.gensalt(rounds=12)  # Strong hashing
            password_hash = bcrypt.hashpw(password.encode('utf-8'), salt)

            # Store password hash and metadata
            password_data = {
                'password_hash': password_hash.decode('utf-8'),
                'salt': salt.decode('utf-8'),
                'created_timestamp': datetime.utcnow().isoformat(),
                'algorithm': 'bcrypt',
                'rounds': 12
            }

            with open(self.password_file, 'w') as f:
                json.dump(password_data, f, indent=2)

            # Set restrictive file permissions
            os.chmod(self.password_file, 0o600)

            return True

        except Exception as e:
            self.log_error(f"Password setting failed: {e}")
            return False

    def verify_password(self, password: str) -> bool:
        """Verify password against stored hash"""
        try:
            with open(self.password_file, 'r') as f:
                password_data = json.load(f)

            stored_hash = password_data['password_hash'].encode('utf-8')
            return bcrypt.checkpw(password.encode('utf-8'), stored_hash)

        except (FileNotFoundError, KeyError, json.JSONDecodeError):
            return False  # No password set or corrupted data

    def is_password_set(self) -> bool:
        """Check if device password has been set"""
        try:
            with open(self.password_file, 'r') as f:
                password_data = json.load(f)
                return 'password_hash' in password_data
        except:
            return False

    def generate_temporary_password(self) -> str:
        """Generate temporary password for initial setup"""
        return secrets.token_urlsafe(12)  # 12-character secure random password
```

### Security API Endpoints Integration
[Source: architecture/unified-project-structure.md]
```python
# Add to HTTP server (integrate with existing endpoints)
from functools import wraps

def require_authentication(f):
    """Decorator to require password authentication"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth_header = request.headers.get('Authorization')

        if not auth_header or not auth_header.startswith('Basic '):
            return jsonify({'error': 'Authentication required'}), 401

        try:
            credentials = base64.b64decode(auth_header[6:]).decode('utf-8')
            username, password = credentials.split(':', 1)

            if username != 'admin' or not password_manager.verify_password(password):
                return jsonify({'error': 'Invalid credentials'}), 401

        except Exception:
            return jsonify({'error': 'Invalid authentication format'}), 401

        return f(*args, **kwargs)
    return decorated_function

@app.route('/setup/password', methods=['POST'])
@rate_limiter.limit("5 per minute")
def setup_device_password():
    """Set initial device password"""
    if password_manager.is_password_set():
        return jsonify({'error': 'Password already set'}), 400

    data = request.get_json()
    if not data or 'password' not in data:
        return jsonify({'error': 'Password required'}), 400

    # Validate password
    validation = input_validator.validate_device_password(data['password'])
    if not validation['valid']:
        return jsonify({
            'error': 'Password validation failed',
            'validation_errors': validation['errors']
        }), 400

    # Set password
    if password_manager.set_device_password(data['password']):
        security_logger.log_security_event('password_set', {'success': True})
        return jsonify({'success': True, 'message': 'Password set successfully'})
    else:
        return jsonify({'error': 'Failed to set password'}), 500

@app.route('/device/security-status', methods=['GET'])
@require_authentication
def get_security_status():
    """Get current security configuration status"""
    return jsonify({
        'certificate_valid': certificate_manager.is_certificate_valid(),
        'certificate_expires': certificate_manager.get_certificate_expiry(),
        'password_set': password_manager.is_password_set(),
        'rate_limiting_active': rate_limiter.is_active(),
        'tls_version': 'TLS 1.2+',
        'security_level': 'V1.0 - Basic'
    })
```

### Security Logging and Monitoring
```python
class SecurityLogger:
    def __init__(self, log_file: str = '/opt/device-software/logs/security.log'):
        self.log_file = log_file

    def log_security_event(self, event_type: str, details: Dict):
        """Log security-related events"""
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'event_type': event_type,
            'details': details,
            'severity': self.get_event_severity(event_type)
        }

        with open(self.log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')

    def get_event_severity(self, event_type: str) -> str:
        """Determine event severity level"""
        high_severity_events = [
            'authentication_failure',
            'rate_limit_exceeded',
            'certificate_error',
            'security_violation'
        ]

        return 'HIGH' if event_type in high_severity_events else 'MEDIUM'
```

### Security Configuration Management
```json
{
  "tls_config": {
    "min_version": "TLSv1.2",
    "cipher_suites": [
      "ECDHE-RSA-AES256-GCM-SHA384",
      "ECDHE-RSA-AES128-GCM-SHA256",
      "DHE-RSA-AES256-GCM-SHA384",
      "DHE-RSA-AES128-GCM-SHA256"
    ],
    "certificate_validity_days": 1825
  },
  "rate_limiting": {
    "enabled": true,
    "requests_per_minute": 30,
    "burst_limit": 100,
    "excluded_endpoints": ["/health"]
  },
  "authentication": {
    "password_required": true,
    "session_timeout": 3600,
    "max_login_attempts": 3,
    "lockout_duration": 900
  },
  "validation": {
    "strict_input_validation": true,
    "sanitize_all_inputs": true,
    "max_payload_size": 1048576
  },
  "security_upgrade_path": {
    "v1_1": {
      "dynamic_tokens": true,
      "encrypted_storage": true
    },
    "v1_2": {
      "certificate_based_auth": true,
      "secure_script_execution": true
    },
    "v2_0": {
      "enterprise_security": true,
      "key_rotation": true,
      "audit_logging": true
    }
  }
}
```

## Testing

### Security Testing Requirements
[Source: architecture/testing-strategy.md]
- **Test File Location:** `/opt/device-software/tests/security/`
- **Testing Framework:** Python unittest with security-focused test cases
- **Coverage Requirements:** 95% minimum for security-critical code
- **Test Categories:**
  - Certificate generation and validation
  - Rate limiting under various load conditions
  - Input validation against common attacks
  - Password security and strength
  - Authentication mechanisms
  - Security logging and monitoring

### Security Test Files Structure
```
/opt/device-software/tests/security/
├── test_certificate_manager.py     # Certificate tests
├── test_rate_limiter.py            # Rate limiting tests
├── test_input_validator.py         # Input validation tests
├── test_password_manager.py        # Password security tests
├── test_auth_middleware.py         # Authentication tests
├── test_security_logger.py         # Security logging tests
└── penetration/
    ├── test_injection_attacks.py   # SQL/XSS injection tests
    ├── test_brute_force.py         # Brute force protection tests
    └── test_certificate_attacks.py # Certificate-based attack tests
```

### Security Vulnerability Testing
```python
# Example security test cases
class SecurityVulnerabilityTests(unittest.TestCase):

    def test_sql_injection_prevention(self):
        """Test protection against SQL injection attacks"""
        malicious_inputs = [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "admin'--",
            "' UNION SELECT * FROM passwords--"
        ]

        for malicious_input in malicious_inputs:
            result = input_validator.validate_wifi_credentials(malicious_input, "password123")
            self.assertFalse(result['valid'])
            self.assertIn('invalid characters', result['errors']['ssid'].lower())

    def test_xss_prevention(self):
        """Test protection against XSS attacks"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "' onmouseover='alert(1)'"
        ]

        for payload in xss_payloads:
            sanitized = input_validator.sanitize_json_input(payload)
            self.assertNotIn('<script>', sanitized)
            self.assertNotIn('javascript:', sanitized)
            self.assertNotIn('onerror=', sanitized)

    def test_brute_force_protection(self):
        """Test rate limiting protects against brute force attacks"""
        # Simulate rapid authentication attempts
        for i in range(50):
            allowed = rate_limiter.is_allowed('192.168.1.100', '/setup/password')
            if i >= 30:  # Should be blocked after rate limit
                self.assertFalse(allowed)
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-01-15 | 1.0 | Initial story creation with comprehensive security foundation requirements | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation*